// LALRPOP Parser Specification
//
// This file is part of AEx.
// Copyright (C) 2015 Jeffrey Sharp
//
// AEx is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// AEx is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
// the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with AEx.  If not, see <http://www.gnu.org/licenses/>.

use ast::*;
use ast::Stmt::*;
use ast::Expr::*;
use interner::{Interner, StrId};
use lexer::{Pos, Token};
use message::Message;

grammar(strings: &Interner)["LALR(1)"];

extern {
    type Location = Pos;
    type Error    = (Pos, Message);

    enum Token {
        Id          => Token::Id   (<StrId>),
        Str         => Token::Str  (<StrId>),
        Char        => Token::Char (<char>),
        Int         => Token::Int  (<u64>),
        "type"      => Token::KwType,        
        "struct"    => Token::KwStruct,      
        "union"     => Token::KwUnion,       
        "if"        => Token::KwIf,          
        "else"      => Token::KwElse,        
        "loop"      => Token::KwLoop,        
        "while"     => Token::KwWhile,       
        "break"     => Token::KwBreak,       
        "continue"  => Token::KwContinue,    
        "return"    => Token::KwReturn,      
        "jump"      => Token::KwJump,        
        "{"         => Token::BraceL,        
        "}"         => Token::BraceR,        
        "("         => Token::ParenL,        
        ")"         => Token::ParenR,        
        "["         => Token::BracketL,      
        "]"         => Token::BracketR,      
        "."         => Token::Dot,           
        "@"         => Token::At,            
        "++"        => Token::PlusPlus,      
        "--"        => Token::MinusMinus,    
        "!"         => Token::Bang,          
        "~"         => Token::Tilde,         
        "?"         => Token::Question,      
        "*"         => Token::Star,          
        "/"         => Token::Slash,         
        "%"         => Token::Percent,       
        "+"         => Token::Plus,          
        "-"         => Token::Minus,         
        "<<"        => Token::LessLess,      
        ">>"        => Token::MoreMore,      
        "&"         => Token::Ampersand,     
        "^"         => Token::Caret,         
        "|"         => Token::Pipe,          
        ".~"        => Token::DotTilde,      
        ".!"        => Token::DotBang,       
        ".="        => Token::DotEqual,      
        ".?"        => Token::DotQuestion,   
        "<>"        => Token::LessMore,      
        "=="        => Token::EqualEqual,    
        "!="        => Token::BangEqual,     
        "<"         => Token::Less,          
        ">"         => Token::More,          
        "<="        => Token::LessEqual,     
        ">="        => Token::MoreEqual,     
        "=>"        => Token::EqualArrow,    
        "->"        => Token::MinusArrow,    
        "="         => Token::Equal,         
        ":"         => Token::Colon,         
        ","         => Token::Comma,         
        ";"         => Token::Eos,           
        Eof         => Token::Eof,           
    }
}

// Macros

// "tuple": A separated list of items. A trailing separator is forbidden.
//
Tup<Item, Sep>: Vec<Item> = {
    <v:(<Item> Sep)*> <i:Item> => { let mut v = v; v.push(i); v }
};

// "sequence": A separated list of items. A trailing separator is ignored.
//
Seq<Item, Sep>: Vec<Item> = {
    <v:(<Item> Sep)*> <i:Item?> => match i {
        None    => v,
        Some(i) => { let mut v = v; v.push(i); v },
    }
};

// Productions

pub Stmts = Seq<Stmt, ";">;

Stmt: Stmt = {
    Expr            => Eval(<>),
    "{" <Stmts> "}" => Block(<>),
};

Expr: Expr = {
    Id  => Ident(<>),
    Int => Int(<>),
};

// vim: ft=rust

