// LALRPOP Parser Specification
//
// This file is part of AEx.
// Copyright (C) 2015 Jeffrey Sharp
//
// AEx is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// AEx is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
// the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with AEx.  If not, see <http://www.gnu.org/licenses/>.

use ast::*;
use ast::Stmt::*;
use ast::Expr::*;
use interner::{Interner, StrId};
use lexer::{Pos, Token};
use message::Message;

grammar(strings: &Interner)["LALR(1)"];

extern {
    type Location = Pos;
    type Error    = (Pos, Message);

    enum Token {
        Raw         => Token::Raw  (<StrId>),
        Id          => Token::Id   (<StrId>),
        Flag        => Token::Flag (<StrId>),

        Int         => Token::Int  (<u64>),
        Char        => Token::Char (<char>),
        Str         => Token::Str  (<StrId>),

        "type"      => Token::KwType,        
        "struct"    => Token::KwStruct,      
        "union"     => Token::KwUnion,       
        "if"        => Token::KwIf,          
        "else"      => Token::KwElse,        
        "loop"      => Token::KwLoop,        
        "while"     => Token::KwWhile,       
        "break"     => Token::KwBreak,       
        "continue"  => Token::KwContinue,    
        "return"    => Token::KwReturn,      
        "jump"      => Token::KwJump,        
        "{"         => Token::BraceL,        
        "}"         => Token::BraceR,        
        "("         => Token::ParenL,        
        ")"         => Token::ParenR,        
        "["         => Token::BracketL,      
        "]"         => Token::BracketR,      
        "."         => Token::Dot,           
        "@"         => Token::At,            
        "++"        => Token::PlusPlus,      
        "--"        => Token::MinusMinus,    
        "!"         => Token::Bang,          
        "~"         => Token::Tilde,         
        "?"         => Token::Question,      
        "*"         => Token::Star,          
        "/"         => Token::Slash,         
        "%"         => Token::Percent,       
        "+"         => Token::Plus,          
        "-"         => Token::Minus,         
        "<<"        => Token::LessLess,      
        ">>"        => Token::MoreMore,      
        "&"         => Token::Ampersand,     
        "^"         => Token::Caret,         
        "|"         => Token::Pipe,          
        ".~"        => Token::DotTilde,      
        ".!"        => Token::DotBang,       
        ".="        => Token::DotEqual,      
        ".?"        => Token::DotQuestion,   
        "<>"        => Token::LessMore,      
        "=="        => Token::EqualEqual,    
        "!="        => Token::BangEqual,     
        "<"         => Token::Less,          
        ">"         => Token::More,          
        "<="        => Token::LessEqual,     
        ">="        => Token::MoreEqual,     
        "=>"        => Token::EqualArrow,    
        "->"        => Token::MinusArrow,    
        "="         => Token::Equal,         
        ":"         => Token::Colon,         
        ","         => Token::Comma,         
        ";"         => Token::Eos,           
        Eof         => Token::Eof,           
    }
}

// Macros

// "tuple": A separated list of items. A trailing separator is forbidden.
//
Tup<Item, Sep>: Vec<Item> = {
    <v:(<Item> Sep)*> <i:Item> => { let mut v = v; v.push(i); v }
};

// "sequence": A separated list of items. A trailing separator is ignored.
//
Seq<Item, Sep>: Vec<Item> = {
    <v:(<Item> Sep)*> <i:Item?> => match i {
        None    => v,
        Some(i) => { let mut v = v; v.push(i); v },
    }
};

// Productions

pub Stmts = Seq<Stmt, ";">;

Stmt: Stmt = {
    Expr            => Eval(<>),
    "{" <Stmts> "}" => Block(<>),
};

Expr: Box<Expr> = {
    Compare,
    <l:Compare> "=" <h:Hint?> <r:Expr> => Box::new(Set    (l, r, h)),
    <l:Compare> "=" <h:Hint?> <r:Test> => Box::new(SetCond(l, r, h)),
};

Compare: Box<Expr> = {
    BitOp,
    <l:Compare> "<>" <h:Hint?> <r:BitOp> => Box::new(Compare(l, r, h)),
};

BitOp: Box<Expr> = {
    Or,
    <l:BitOp> ".~" <h:Hint?> <r:Or> => Box::new(BitChange(l, r, h)),
    <l:BitOp> ".!" <h:Hint?> <r:Or> => Box::new(BitClear (l, r, h)),
    <l:BitOp> ".=" <h:Hint?> <r:Or> => Box::new(BitSet   (l, r, h)),
    <l:BitOp> ".?" <h:Hint?> <r:Or> => Box::new(BitTest  (l, r, h)),
};

Or: Box<Expr> = {
    And,
    <l:Or> "|" <h:Hint?> <r:And> => Box::new(BitOr (l, r, h)),
    <l:Or> "^" <h:Hint?> <r:And> => Box::new(BitXor(l, r, h)),
};

And: Box<Expr> = {
    Shift,
    <l:And> "&" <h:Hint?> <r:Shift> => Box::new(BitAnd(l, r, h)),
};

Shift: Box<Expr> = {
    Term,
    <l:Shift> "<<" <h:Hint?> <r:Term> => Box::new(ShiftL(l, r, h)),
    <l:Shift> ">>" <h:Hint?> <r:Term> => Box::new(ShiftR(l, r, h)),
};

Term: Box<Expr> = {
    Factor,
    <l:Term> "+" <h:Hint?> <r:Factor> => Box::new(Add     (l, r, h)),
    <l:Term> "-" <h:Hint?> <r:Factor> => Box::new(Subtract(l, r, h)),
};

Factor: Box<Expr> = {
    UnaryR,
    <l:Factor> "*" <h:Hint?> <r:UnaryR> => Box::new(Multiply(l, r, h)),
    <l:Factor> "/" <h:Hint?> <r:UnaryR> => Box::new(Divide  (l, r, h)),
    <l:Factor> "%" <h:Hint?> <r:UnaryR> => Box::new(Modulo  (l, r, h)),
};

UnaryR: Box<Expr> = {
    UnaryL,
    "!" <h:Hint?> <e:UnaryR> => Box::new(Clear     (e, h)),
    "-" <h:Hint?> <e:UnaryR> => Box::new(Negate    (e, h)),
    "~" <h:Hint?> <e:UnaryR> => Box::new(Complement(e, h)),
};

UnaryL: Box<Expr> = {
    Atom,
    <e:UnaryL> "."  <i:Id>    => Box::new(MemberOf (e, i)),
    <e:UnaryL> "--" <h:Hint?> => Box::new(Decrement(e, h)),
    <e:UnaryL> "++" <h:Hint?> => Box::new(Increment(e, h)),
};

Atom: Box<Expr> = {
    Id  => Box::new(Ident(<>)),
    Int => Box::new(Int  (<>)),
    "(" <Expr> ")",
};

// Conditions

Test: Box<Test> = {
    <f:Flag> => {
        Box::new(Test(f, None))
    },
    <e:Compare> "=>" <f:Flag> => {
        Box::new(Test(f, Some(e)))
    },
    <l:Compare> <f:Rel> <h:Hint?> <r:Compare> => {
        Box::new(Test(f, Some(Box::new(Compare(l, r, h)))))
    },
};

Rel: StrId = {
    "==" => strings.intern("=="),
    "!=" => strings.intern("!="),
    "<"  => strings.intern("<" ),
    ">"  => strings.intern(">" ),
    "<=" => strings.intern("<="),
    ">=" => strings.intern(">="),
};

// Misc

Hint = ":" <Id>;

// vim: ft=rust

